use color_eyre::{Result, eyre::anyhow};
use colored::Colorize;
use libp2p::PeerId;
use tracing::{info, debug, error, warn};
use sha3::{Digest, Keccak256};

use crate::network_events::NodeIdentity;
use crate::types::{
    ReverieNameWithNonce,
    NetworkEvent,
    RespawnId,
    NodeKeysWithVesselStatus,
    Reverie,
    ReverieId,
    ReverieType,
    AgentVesselInfo,
    AccessCondition,
    AccessKey,
};
use crate::behaviour::heartbeat_behaviour::TeePayloadOutEvent;
use runtime::reencrypt::{UmbralKey, VerifiedCapsuleFrag};
use runtime::llm::AgentSecretsJson;

use super::commands::NodeCommand;
use super::NodeClient;



impl<'a> NodeClient<'a> {

    /// Client sends AgentSecretsJson over TLS or some secure channel.
    /// Node encrypts with PRE and broadcasts fragments to the network
    pub async fn spawn_agent(
        &mut self,
        agent_secrets: AgentSecretsJson,
        threshold: usize,
        total_frags: usize,
    ) -> Result<NodeKeysWithVesselStatus> {

        if threshold > total_frags {
            return Err(anyhow!("Threshold must be less than or equal to total fragments"));
        }

        let agent_name_nonce = ReverieNameWithNonce(
            agent_secrets.agent_name.clone(),
            agent_secrets.agent_nonce.clone()
        );

        // get list of target vessel and kfrag provider nodes
        let (
            target_vessel,
            target_kfrag_providers
        ) = self.get_prospect_vessels(false).await?;

        // Create a "Reverie"––an encrypted memory that alters how a Host behaves
        let (
            capsule,
            ciphertext
        ) = self.umbral_key.encrypt_bytes(&serde_json::to_vec(&agent_secrets)?)?;

        let reverie = Reverie::new(
            "secrets description".to_string(),
            // secrets description: generated by an LLM who looks at the secrets/MCP/executable
            ReverieType::SovereignAgent(agent_name_nonce),
            threshold,
            total_frags,
            target_vessel.umbral_public_key,
            target_vessel.umbral_verifying_public_key,
            AccessCondition::Umbral(target_vessel.umbral_verifying_public_key),
            capsule,
            ciphertext
        );

        self.broadcast_reverie_keyfrags(&reverie, target_vessel.peer_id, target_kfrag_providers).await?;

        info!("RequestResponse broadcast of kfrags complete.");

        Ok(target_vessel)
    }

    pub(super) async fn handle_respawn_request(
        &mut self,
        prev_reverie_id: ReverieId,
        prev_reverie_type: ReverieType,
        threshold: usize,
        total_frags: usize,
        next_vessel_peer_id: PeerId,    // This node is the next vessel
        prev_failed_vessel_peer_id: PeerId, // Previous (failed) vessel
    ) -> Result<()> {

        let prev_agent_name_nonce = match &prev_reverie_type {
            ReverieType::SovereignAgent(agent_name_nonce) => agent_name_nonce.clone(),
            _ => return Err(anyhow!("Previous Reverie is not a SovereignAgent")),
        };
        info!("\nHandle respawn request: {:?}", prev_agent_name_nonce);
        info!("total_frags: {:?}", total_frags);
        info!("next_vessel_peer_id: {:?}", next_vessel_peer_id);
        info!("prev_failed_vessel_peer_id: {:?}", prev_failed_vessel_peer_id);

        let prev_agent = prev_agent_name_nonce.clone();
        let next_agent = prev_agent_name_nonce.increment_nonce();
        let next_nonce = next_agent.nonce();

        let mut agent_secrets_json = self.reconstruct_agent_secrets_cfrags(
            prev_reverie_id.clone(),
            prev_reverie_type,
            prev_failed_vessel_peer_id
        ).await?;

        agent_secrets_json.agent_nonce = next_nonce;

        // Respawn checks:
        // 1. test LLM API works
        // 2. re-encrypt secrets + provide TEE attestation of it
        // 3. mark respawn complete / old vessel died

        // 1. Test LLM API key from decrypted Reverie works
        if let Some(_anthropic_api_key) = agent_secrets_json.anthropic_api_key.clone() {
            info!("Decrypted LLM API keys, querying LLM (paused)");
            // let response = runtime::llm::test_claude_query(
            //     _anthropic_api_key,
            //     "What is your name and what do you do?",
            //     &agent_secrets_json.context
            // ).await.unwrap();
            // info!("\n{} {}\n", "Claude:".bright_black(), response.yellow());
        }

        // 2. get a new list of target vessel and kfrag provider nodes
        let (
            target_vessel,
            target_kfrag_providers
        ) = self.get_prospect_vessels(false).await?;

        // 3. re-encrypt secrets + provide TEE attestation of it
        let reverie = self.create_reverie(
            agent_secrets_json.clone(),
            ReverieType::SovereignAgent(next_agent.clone()),
            threshold,
            total_frags,
            target_vessel.umbral_public_key,
            // in this case verifying_public_key is the same as the access_key
            target_vessel.umbral_verifying_public_key,
            AccessCondition::Umbral(target_vessel.umbral_verifying_public_key),
        )?;
        info!("Encrypted Secrets:\n{}", format!("{}", hex::encode(reverie.umbral_ciphertext.clone())).black());

        // 4. broadcast keyfrags to new providers
        self.broadcast_reverie_keyfrags(
            &reverie,
            target_vessel.peer_id,
            target_kfrag_providers
        ).await?;

        // 5. mark respawn complete / old vessel died
        self.command_sender.send(NodeCommand::MarkPendingRespawnComplete {
            prev_reverie_id: prev_reverie_id.clone(),
            prev_peer_id: prev_failed_vessel_peer_id,
            prev_agent_name_nonce: prev_agent,
        }).await.ok();

        info!("\n\n\t{}\n", format!("Respawn Request complete.").green());
        Ok(())
    }

    // This needs to happen within the TEE as there is a decryption step, and the original
    // plaintext is revealed within the TEE, before being re-encrypted under PRE again.
    pub async fn reconstruct_agent_secrets_cfrags(
        &mut self,
        prev_reverie_id: ReverieId,
        prev_reverie_type: ReverieType,
        prev_failed_vessel_peer_id: PeerId
    ) -> Result<AgentSecretsJson> {

        let reverie_msg = self.get_reverie(&prev_reverie_id, prev_reverie_type).await?;
        let prev_kfrag_providers = reverie_msg.keyfrag_providers.clone();
        let capsule = reverie_msg.reverie.encode_capsule()?;

        // target vessel creates signature by signing the digest hash of reverie_id
        let digest = Keccak256::digest(reverie_msg.reverie.id.clone().as_bytes());
        // Sign with our umbral signer key (corresponds to the verifying key)
        let umbral_signature = self.umbral_key.sign(&digest);
        let cfrags_raw = self.request_cfrags(
            &prev_reverie_id,
            prev_kfrag_providers,
            AccessKey::UmbralSignature(
                serde_json::to_vec(&umbral_signature)
                    .expect("Failed to serialize umbral signature"))
        ).await;

        let (
            verified_cfrags,
            delegator_pubkey,
            target_verifying_pubkey,
            access_pubkey,
            total_frags_received
        ) = self.parse_cfrags(cfrags_raw, capsule.clone())?;

        let next_agent_secrets = self.decrypt_cfrags(
            capsule,
            reverie_msg.reverie.umbral_ciphertext,
            delegator_pubkey,
            verified_cfrags,
        );

        next_agent_secrets
    }

}
