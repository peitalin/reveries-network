use hex;
use color_eyre::Result;
pub use dcap_rs::types::quotes::version_4::QuoteV4;
use crate::tee_mock_attestation::{
    TEE_MOCK_ATTESTATION_REPORT,
    TEE_MOCK_ATTESTATION_REPORT2
};


#[cfg(all(target_os = "linux", feature = "tdx_enabled"))]
use tdx::{device::DeviceOptions, Tdx};

#[cfg(all(target_os = "linux", feature = "tdx_enabled"))]
pub fn generate_tee_attestation(log: bool) -> Result<(QuoteV4, Vec<u8>)> {
    // Initialise a TDX object
    let tdx: Tdx = Tdx::new();
    // Retrieve an attestation report with options to report the hardware device
    // https://github.com/automata-network/tdx-attestation-sdk/blob/a827ce104bbec73ba801f3eb7caa750c142e3b87/tdx/src/lib.rs#L19
    let raw_report: Vec<u8> = tdx.get_attestation_report_raw_with_options(
        DeviceOptions { report_data: Some([0; 64]) }
    )?;
    let attestation_report = QuoteV4::from_bytes(&raw_report);
    if log {
        println!("Attestation Report raw bytes: 0x{}", hex::encode(&raw_report));
        log_quote_v4_attestation(&attestation_report);
    }
    println!("\nThis is a REAL TDX Attestation");
    let attestation_bytes = raw_report;
    Ok((attestation_report, attestation_bytes))
}

#[cfg(not(all(target_os = "linux", feature = "tdx_enabled")))]
pub fn generate_tee_attestation(log: bool) -> Result<(QuoteV4, Vec<u8>)> {
    let attestation_bytes = hex::decode(TEE_MOCK_ATTESTATION_REPORT)?;
    let attestation_report = QuoteV4::from_bytes(&attestation_bytes);
    if log {
        log_quote_v4_attestation(&attestation_report);
    }
    // println!("\nTHIS IS A MOCK TDX Attestation.\nReal proofs only on TDX enabled Linux VMs");
    // println!("You must also compile with the 'tdx_enabled' feature flag");
    Ok((attestation_report, attestation_bytes))
}

fn log_quote_v4_attestation(attestation: &QuoteV4) {

    println!("TEE QuoteV4 Attestation:\n{:?}\n", attestation);
    println!("TEE type: {:?}", attestation.header.tee_type);

    // qe_cert_data: CertData,
    // [variable bytes]
    println!(
        "signature.eq_cert_data:\n{:?}\n",
        attestation.signature.qe_cert_data
    );

    // quote_signature: [u8; 64],
    // ECDSA signature, the r component followed by the s component, 2 x 32 bytes.
    // Public part of the Attestation Key generated by1 the Quoting Enclave.
    println!(
        "signature.quote_signature:\n0x{}\n",
        hex::encode(attestation.signature.quote_signature)
    );

    // ecdsa_attestation_key: [u8; 64],
    // EC KT-I Public Key, the x-coordinate followed by the y-coordinate (on the RFC 6090 P-256 curve), 2 x 32 bytes.
    // Public part of the Attestation Key generated by the Quoting Enclave.
    println!(
        "signature.ecdsa_attestation_key:\n0x{}\nlength: {}",
        hex::encode(attestation.signature.ecdsa_attestation_key),
        attestation.signature.ecdsa_attestation_key.len()
    );
    println!("\nattestation.signature_len: {}", attestation.signature_len);
    println!("total attestation length: {}", TEE_MOCK_ATTESTATION_REPORT.len());

    let os = std::env::consts::OS;
    println!("Operating System: {}", os);
}


#[cfg(test)]
mod tests {
    use super::*;
    use color_eyre::Result;
    use dcap_rs::{
        types::collaterals::IntelCollateral,
        utils::quotes::version_4::verify_quote_dcapv4,
        utils::cert::{hash_x509_keccak256, hash_crl_keccak256},
    };

    #[test]
    fn test_verify_tee_attestation() -> Result<()> {
        // Pinned September 10th, 2024, 6:49am GMT
        // there's no need for constant sample collateral updates
        const PINNED_TIME: u64 = 1739419232;

        // Parse the first mock attestation report
        let quote_bytes1 = hex::decode(TEE_MOCK_ATTESTATION_REPORT)?;
        let dcap_quote1 = QuoteV4::from_bytes(&quote_bytes1);

        // Parse the second mock attestation report
        let quote_bytes2 = hex::decode(TEE_MOCK_ATTESTATION_REPORT2)?;
        let dcap_quote2 = QuoteV4::from_bytes(&quote_bytes2);

        // Create Intel collaterals using the downloaded files
        let mut collaterals = IntelCollateral::new();
        collaterals.set_tcbinfo_bytes(include_bytes!("../data/tcbinfov3_00806f050000.json"));
        collaterals.set_qeidentity_bytes(include_bytes!("../data/qeidentityv2_apiv4.json"));
        collaterals.set_intel_root_ca_der(include_bytes!("../data/Intel_SGX_Provisioning_Certification_RootCA.cer"));
        collaterals.set_sgx_tcb_signing_pem(include_bytes!("../data/signing_cert.pem"));
        collaterals.set_sgx_intel_root_ca_crl_der(include_bytes!("../data/intel_root_ca_crl.der"));
        collaterals.set_sgx_platform_crl_der(include_bytes!("../data/pck_platform_crl.der"));
        // collaterals.set_sgx_processor_crl_der(include_bytes!("../data/pck_processor_crl.der"));

        // Verify the first mock attestation
        println!("Verifying first mock attestation report");
        let verified_output1 = verify_quote_dcapv4(&dcap_quote1, &collaterals, PINNED_TIME);

        // Output verification results
        println!("TEE type: {}", verified_output1.tee_type);
        println!("TCB status: {:?}", verified_output1.tcb_status);
        assert_eq!(verified_output1.quote_version, 4, "First quote version should be 4");

        // Verify the second mock attestation
        println!("Verifying second mock attestation report");
        let verified_output2 = verify_quote_dcapv4(&dcap_quote2, &collaterals, PINNED_TIME);

        // Output verification results for the second report
        println!("TEE type: {}", verified_output2.tee_type);
        println!("TCB status: {:?}", verified_output2.tcb_status);
        assert_eq!(verified_output2.quote_version, 4, "Second quote version should be 4");

        let root_hash = hash_x509_keccak256(&collaterals.get_sgx_intel_root_ca());
        let sign_hash = hash_x509_keccak256(&collaterals.get_sgx_tcb_signing());
        let crl_hash = hash_crl_keccak256(&collaterals.get_sgx_intel_root_ca_crl().unwrap());
        println!("root_hash: 0x{}", hex::encode(root_hash));
        println!("sign_hash: 0x{}", hex::encode(sign_hash));
        println!("crl_hash: 0x{}", hex::encode(crl_hash));

        Ok(())
    }
}
